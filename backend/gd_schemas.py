from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime
from enum import Enum

class ParticipantRole(str, Enum):
    HUMAN = "human"
    AI = "ai"

class SessionStatus(str, Enum):
    WAITING = "waiting"
    ACTIVE = "active"
    COMPLETED = "completed"

class ParticipantModel(BaseModel):
    participantId: str
    sessionId: str
    peerId: Optional[str] = None
    role: ParticipantRole
    joinedAt: datetime = Field(default_factory=datetime.utcnow)
    name: Optional[str] = None # For display
    roomId: Optional[str] = None # Assigned room

class RoomModel(BaseModel):
    roomId: str
    sessionId: str
    participants: List[str] = [] # List of peerIds
    aiCount: int = 0
    createdAt: datetime = Field(default_factory=datetime.utcnow)
    
    # Scalable Bot Fields (Moved from SessionModel)
    script: List[dict] = [] # Stores [{"sentiment": "For", "text": "..."}]
    current_script_index: int = 0 
    isUserTalking: bool = False
    topic: str

class SessionModel(BaseModel):
    sessionId: str
    status: SessionStatus = SessionStatus.WAITING
    createdAt: datetime = Field(default_factory=datetime.utcnow)
    startTime: Optional[datetime] = None
    endTime: Optional[datetime] = None
    
    # Session is now just the LOBBY / Wrapper.
    # Actual GD state is in RoomModel.

class TranscriptEntry(BaseModel):
    sessionId: str
    roomId: Optional[str] = None # Support routing by room
    speakerId: str # participantId or peerId
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    text: str
    isFinal: bool = False # Web Speech API sends interim results

class CreateSessionRequest(BaseModel):
    topic: str

class JoinSessionRequest(BaseModel):
    sessionId: str
    participantId: str # or username, and we gen ID
    peerId: str # Generated by PeerJS on client
    name: str

class JoinLobbyRequest(BaseModel):
    participantId: str
    peerId: str
    name: str
